<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Slow Growth Transparent - Notion Serif</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            /* Hintergrund ist transparent f端r Notion */
            background-color: transparent; 
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            /* Notion Serif Font Stack */
            font-family: Lyon-Text, Georgia, ui-serif, serif;
        }

        canvas {
            display: block;
        }

        .label {
            position: absolute;
            top: 25px;
            left: 25px;
            /* Textfarbe passend zur Linie */
            color: #F3EDEEE; 
            /* Notion-Serif-Look Optimierungen */
            font-family: Lyon-Text, Georgia, ui-serif, serif;
            font-size: 18px; 
            letter-spacing: -0.2px;
            opacity: 0.85;
            font-weight: 500;
            /* 'text-transform: uppercase' wurde entfernt f端r den klassischen Notion-Look */
        }
    </style>
</head>
<body>

    <div class="label">Personal Growth</div>
    <canvas id="growthCanvas"></canvas>

    <script>
        const canvas = document.getElementById('growthCanvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let progress = 0;
        
        // --- EINSTELLUNGEN ---
        let speed = 0.0006; // Langsame Geschwindigkeit
        let pauseDuration = 200; // Pause am Ende
        // ---------------------

        let pause = 0;
        let points = [];
        
        // --- FARBEN ---
        const lineColor = '#F3EEEE'; 
        const gradientStart = 'rgba(245, 237, 237, 0.15)'; 
        const gradientEnd = 'rgba(245, 237, 237, 0)';     

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            generatePath();
        }

        function generatePath() {
            points = [];
            const segments = 400; 
            
            for (let i = 0; i <= segments; i++) {
                const x = (width / segments) * i;
                // Exponentieller Anstieg
                const rise = (Math.pow(i / segments, 2)) * (height * 0.6);
                // Leichtes Rauschen f端r organischen Look
                const noise = (Math.random() - 0.5) * 10;
                let y = (height * 0.8) - rise + noise;
                points.push({x, y});
            }
        }

        function draw() {
            ctx.clearRect(0, 0, width, height);

            if (pause > 0) {
                pause--;
                drawCurve(points.length);
                requestAnimationFrame(draw);
                return;
            }

            const currentPointIndex = Math.floor(points.length * progress);
            drawCurve(currentPointIndex);

            progress += speed;

            if (progress >= 1) {
                pause = pauseDuration; 
                progress = 0;
                generatePath(); 
            }

            requestAnimationFrame(draw);
        }

        function drawCurve(maxIndex) {
            if (maxIndex < 1) return;

            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);

            for (let i = 1; i < maxIndex; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }

            ctx.strokeStyle = lineColor;
            ctx.lineWidth = 2.5; 
            ctx.lineCap = 'round';
            
            ctx.shadowBlur = 10; 
            ctx.shadowColor = lineColor;
            ctx.stroke();

            // Gradient f端llen
            ctx.lineTo(points[maxIndex - 1].x, height);
            ctx.lineTo(0, height);
            ctx.closePath();
            
            const gradient = ctx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, gradientStart);
            gradient.addColorStop(1, gradientEnd);
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // Punkt an der Spitze
            const lastPoint = points[maxIndex - 1];
            ctx.beginPath();
            ctx.arc(lastPoint.x, lastPoint.y, 3, 0, Math.PI * 2);
            ctx.fillStyle = '#fff';
            ctx.shadowBlur = 5;
            ctx.shadowColor = '#fff';
            ctx.fill();
        }

        window.addEventListener('resize', resize);
        resize();
        requestAnimationFrame(draw);

    </script>
</body>
</html>