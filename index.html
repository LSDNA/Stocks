<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Slow Growth Transparent</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            /* Hintergrund ist jetzt transparent */
            background-color: transparent; 
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }

        canvas {
            display: block;
        }

        .label {
            position: absolute;
            top: 20px;
            left: 20px;
            /* Die Textfarbe passt sich jetzt der Linie an */
            color: #C4A484; 
            font-size: 14px;
            letter-spacing: 1px;
            opacity: 0.9;
            text-transform: uppercase;
            font-weight: 600;
        }
    </style>
</head>
<body>

    <div class="label">Personal Growth</div>
    <canvas id="growthCanvas"></canvas>

    <script>
        const canvas = document.getElementById('growthCanvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let progress = 0;
        
        // --- EINSTELLUNGEN ---
        let speed = 0.00016; // Langsame Geschwindigkeit
        let pauseDuration = 200; // Pause am Ende
        // ---------------------

        let pause = 0;
        let points = [];
        
        // --- FARBEN (Beige / Leichtes Braun) ---
        // Hex Code: #C4A484 (Light Brown / Beige)
        const lineColor = '#C4A484'; 
        
        // Der Schatten unter der Linie (RGB Werte von C4A484 sind 196, 164, 132)
        const gradientStart = 'rgba(196, 164, 132, 0.2)'; // 20% Sichtbarkeit
        const gradientEnd = 'rgba(196, 164, 132, 0)';     // 0% Sichtbarkeit (Transparent)

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            generatePath();
        }

        function generatePath() {
            points = [];
            const segments = 400; // Hohe Auflösung für weiche Linie
            
            for (let i = 0; i <= segments; i++) {
                const x = (width / segments) * i;
                
                // Exponentieller Anstieg
                const rise = (Math.pow(i / segments, 2)) * (height * 0.6);
                
                // Noise
                const noise = (Math.random() - 0.5) * 10;
                
                let y = (height * 0.8) - rise + noise;
                points.push({x, y});
            }
        }

        function draw() {
            // clearRect sorgt dafür, dass der Hintergrund transparent bleibt
            ctx.clearRect(0, 0, width, height);

            if (pause > 0) {
                pause--;
                drawCurve(points.length);
                requestAnimationFrame(draw);
                return;
            }

            const currentPointIndex = Math.floor(points.length * progress);
            
            drawCurve(currentPointIndex);

            progress += speed;

            if (progress >= 1) {
                pause = pauseDuration; 
                progress = 0;
                generatePath(); 
            }

            requestAnimationFrame(draw);
        }

        function drawCurve(maxIndex) {
            if (maxIndex < 1) return;

            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);

            for (let i = 1; i < maxIndex; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }

            ctx.strokeStyle = lineColor;
            ctx.lineWidth = 2.5; // Linie etwas dicker gemacht für bessere Sichtbarkeit
            ctx.lineCap = 'round';
            
            // Glow etwas reduziert für cleaneren Look
            ctx.shadowBlur = 10; 
            ctx.shadowColor = lineColor;
            ctx.stroke();

            // Gradient füllen
            ctx.lineTo(points[maxIndex - 1].x, height);
            ctx.lineTo(0, height);
            ctx.closePath();
            
            const gradient = ctx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, gradientStart);
            gradient.addColorStop(1, gradientEnd);
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // Punkt an der Spitze
            const lastPoint = points[maxIndex - 1];
            ctx.beginPath();
            ctx.arc(lastPoint.x, lastPoint.y, 3, 0, Math.PI * 2);
            ctx.fillStyle = '#fff'; // Der Punkt bleibt weiß als Kontrast
            ctx.shadowBlur = 5;
            ctx.shadowColor = '#fff';
            ctx.fill();
        }

        window.addEventListener('resize', resize);
        resize();
        requestAnimationFrame(draw);

    </script>
</body>
</html>